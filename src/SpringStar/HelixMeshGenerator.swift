import RealityKit
import simd

// This is a function generated by ChatGPT on 09/19/25 which creates a helix mesh
// this will not be part of the final project, this is just for the sandbox
func generateHelixMesh(
    radius: Float = 0.05,
    pitch: Float = 0.05,
    coils: Int = 8,
    tubeRadius: Float = 0.005,
    tubeSegments: Int = 16,
    segmentsPerCoil: Int = 48
) throws -> MeshResource {

    let twoPi = Float.pi * 2
    let totalSegments = coils * segmentsPerCoil
    let totalTurns = Float(coils)
    let height = pitch * totalTurns  // Total height of the spring

    var centers = [SIMD3<Float>]()
    var tangents = [SIMD3<Float>]()

    // 1. Calculate helix center points and tangents, centered vertically
    for i in 0...totalSegments {
        let t = Float(i) / Float(segmentsPerCoil) * twoPi

        // Helix parametric coords (coiling around y-axis)
        let x = radius * cos(t)
        let z = radius * sin(t)
        let y = pitch * t / twoPi - height / 2  // CENTERED vertically here

        centers.append(SIMD3<Float>(x, y, z))

        // Tangent vector (derivative)
        let dx = -radius * sin(t)
        let dz = radius * cos(t)
        let dy = pitch / twoPi

        let tangent = normalize(SIMD3<Float>(dx, dy, dz))
        tangents.append(tangent)
    }

    // 2. Calculate normals and binormals for tube orientation
    var normals = [SIMD3<Float>]()
    var binormals = [SIMD3<Float>]()

    // Choose arbitrary vector for initial normal calculation
    let arbitrary = SIMD3<Float>(0, 1, 0)

    for i in 0...totalSegments {
        let tangent = tangents[i]

        // If tangent and arbitrary vector are almost parallel, choose another arbitrary vector
        var normal = simd_cross(tangent, arbitrary)
        if simd_length(normal) < 0.001 {
            normal = simd_cross(tangent, SIMD3<Float>(1, 0, 0))
        }
        normal = normalize(normal)

        let binormal = normalize(simd_cross(tangent, normal))

        normals.append(normal)
        binormals.append(binormal)
    }

    // 3. Build vertex positions for tube mesh
    var vertices = [SIMD3<Float>]()
    var normalsForVertices = [SIMD3<Float>]()
    var uvs = [SIMD2<Float>]()

    for i in 0...totalSegments {
        for j in 0..<tubeSegments {
            let theta = Float(j) / Float(tubeSegments) * twoPi

            // Position around tube cross-section circle
            let circlePos = normals[i] * cos(theta) * tubeRadius + binormals[i] * sin(theta) * tubeRadius

            let vertexPos = centers[i] + circlePos
            vertices.append(vertexPos)

            normalsForVertices.append(normalize(circlePos))

            // UV mapping (simple cylindrical)
            let u = Float(j) / Float(tubeSegments)
            let v = Float(i) / Float(totalSegments)
            uvs.append(SIMD2<Float>(u, v))
        }
    }

    // 4. Build triangle indices for mesh connectivity
    var indices = [UInt32]()

    for i in 0..<totalSegments {
        for j in 0..<tubeSegments {
            let nextJ = (j + 1) % tubeSegments

            let i0 = UInt32(i * tubeSegments + j)
            let i1 = UInt32((i + 1) * tubeSegments + j)
            let i2 = UInt32((i + 1) * tubeSegments + nextJ)
            let i3 = UInt32(i * tubeSegments + nextJ)

            // Two triangles per quad
            indices.append(contentsOf: [i0, i1, i2])
            indices.append(contentsOf: [i0, i2, i3])
        }
    }

    // 5. Create MeshDescriptor and build mesh resource

    var descriptor = MeshDescriptor()
    descriptor.positions = MeshBuffers.Positions(vertices)
    descriptor.normals = MeshBuffers.Normals(normalsForVertices)
    descriptor.textureCoordinates = MeshBuffers.TextureCoordinates(uvs)
    descriptor.primitives = .triangles(indices)

    return try MeshResource.generate(from: [descriptor])
}
